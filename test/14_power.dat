//  Algorithm Power
//    Created by LemonAtsu at 2016/01/13
// 
//    Given number x and a.
//    Compute x^a
//    Mem[1024] = x, Mem[1025] = a.
// 
//    Procedure as follow :
//      AlgorithmPower() {
//        R[1] = 1
//        R[2] = a
//        R[3] = x
//        while (R[2] > 0) {
//          if(R[2] mod 2 == 1) {
//            R[1] = R[1] * R[3]
//          }
//          R[3] = R[3] * R[3]
//          R[2] = R[2] div 2
//        }
//        Store R[1] to Mem 1026
//    }
//
//    In this testcase, x = 3, a = 5 by default.
//  
//
//  This algorithm is in Introduction to Algorithm 3rd
//  So if you are not familiar with this procdure ...
//  It's fine, it just works.


// Code Segment starts at 0
@0
0100010_00001_00000__000000000000001  //          ADI  R1, R0, #1  
0100010_10000_00000__000010000000001  //          ADI  R16, R0, #1025
0010000_00010_10000__000000000000000  //          LD   R2, M[R16]     //  R2 = Mem[1025] = 5
0100010_10000_00000__000010000000000  //          ADI  R16, R0, #1024 
0010000_00011_10000__000000000000000  //          LD   R3, M[R16]     // R3 = Mem[1024] = 3

// Mod process
0101000_00101_00010__000000000000001  //    mod:  ANI  R5, R2, #1     // check the last bit (mod)
1100000_00000_00101__000000000000100  //          BZ   R3, next (+5)  
0100101_00110_00011__000000000000001  //          SBI  R6, R3, #1
1000000_00111_00001__000000000000000  //          MOVA R6, R1

// Calculate R[1] = R[1] * R[3]
0000010_00001_00001_00111_0000000000  // mult_1:  ADD  R1, R1, R3
0100101_00110_00110__000000000000001  //          SBI  R6, R6, #1
1001000_00000_00110__111111111111101  //          BNZ  R6, mult_1 (-3)

// Calculate R[2] = R[2] div 2
0001101_00010_00000_00010_0000000001  //   next:  LSR  R2, R2, #1
1100000_00000_00010__000000000000110  //          BZ   R2, done (+6)  // If R2 = 0, jump to done to avoid overhead

// Calculate R[3] = R[3] * R[3]
0100101_00110_00011__000000000000001  //          SBI  R6, R3, #1
1000000_00111_00011__000000000000000  //          MOVA R7, R3
0000010_00011_00011_00111_0000000000  // mult_2:  ADD  R3, R3, R7
0100101_00110_00110__000000000000001  //          SBI  R6, R6, #1
1001000_00000_00110__111111111111101  //          BNZ  R6, mult_2 (-3)


// If R[2] > 0, Back to Mod
1001000_00000_00010__111111111110001  //          BNZ  R2, mod (-15)
0100010_10010_00000__000010000000010  //   done:  ADI  R16, R0, #1026
0100000_00000_10010_00001_0000000000  //          ST   M[R18], R1



0000000_00000_00000__000000000000000  //          NOP
0000000_00000_00000__000000000000000  //          NOP
0000000_00000_00000__000000000000000  //          NOP
0000000_00000_00000__000000000000000  //          NOP
0000000_00000_00000__000000000000000  //          NOP
1111111_11111_11111__111111111111111  //          HALT
0000000_00000_00000__000000000000000  //          NOP
0000000_00000_00000__000000000000000  //          NOP
0000000_00000_00000__000000000000000  //          NOP
0000000_00000_00000__000000000000000  //          NOP

// Data Segment starts at 1024 = 0x400h
@400
00000000_00000000_00000000_00000011   // 3
00000000_00000000_00000000_00000101   // 5
// 1792 = 0x700h
@700
0000000_00000_00000__000000000000000  //          NOP
0000000_00000_00000__000000000000000  //          NOP

